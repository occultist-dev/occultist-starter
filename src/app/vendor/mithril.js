
/**
 * This is a modified copy of Mithril.js https://github.com/MithrilJS/mithril.js.
 * Licence from source repo.
 *
 * The MIT License (MIT)
 * Copyright (c) 2017 Leo Horie
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


function Vnode(tag, key, attrs0, children, text, dom) {
	return {tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, is: undefined, domSize: undefined, state: undefined, events: undefined, instance: undefined}
}
Vnode.normalize = function(node) {
	if (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)
	if (node == null || typeof node === "boolean") return null
	if (typeof node === "object") return node
	return Vnode("#", undefined, undefined, String(node), undefined, undefined)
}
Vnode.normalizeChildren = function(input) {
	// Preallocate the array length (initially holey) and fill every index immediately in order.
	// Benchmarking shows better performance on V8.
	var children = new Array(input.length)
	// Count the number of keyed normalized vnodes for consistency check.
	// Note: this is a perf-sensitive check.
	// Fun fact: merging the loop like this is somehow faster than splitting
	// the check within updateNodes(), noticeably so.
	var numKeyed = 0
	for (var i = 0; i < input.length; i++) {
		children[i] = Vnode.normalize(input[i])
		if (children[i] !== null && children[i].key != null) numKeyed++
	}
	if (numKeyed !== 0 && numKeyed !== input.length) {
		throw new TypeError(children.includes(null)
			? "In fragments, vnodes must either all have keys or none have keys. You may wish to consider using an explicit keyed empty fragment, m.fragment({key: ...}), instead of a hole."
			: "In fragments, vnodes must either all have keys or none have keys."
		)
	}
	return children
}
// Note: the processing of variadic parameters is perf-sensitive.
//
// In native ES6, it might be preferable to define hyperscript and fragment
// factories with a final ...args parameter and call hyperscriptVnode(...args),
// since modern engines can optimize spread calls.
//
// However, benchmarks showed this was not faster. As a result, spread is used
// only in the parameter lists of hyperscript and fragment, while an array is
// passed to hyperscriptVnode.
var hyperscriptVnode = function(attrs1, children0) {
	if (attrs1 == null || typeof attrs1 === "object" && attrs1.tag == null && !Array.isArray(attrs1)) {
		if (children0.length === 1 && Array.isArray(children0[0])) children0 = children0[0]
	} else {
		children0 = children0.length === 0 && Array.isArray(attrs1) ? attrs1 : [attrs1, ...children0]
		attrs1 = undefined
	}
	return Vnode("", attrs1 && attrs1.key, attrs1, children0)
}
// This exists so I'm only saving it once.
var hasOwn = {}.hasOwnProperty
// This is an attrs object that is used by default when attrs is undefined or null.
var emptyAttrs = {}
// This Map manages the following:
// - Whether an attrs is cached attrs generated by compileSelector().
// - Whether the cached attrs is "static", i.e., does not contain any form attributes.
// These information will be useful to skip updating attrs in render().
//
// Since the attrs used as keys in this map are not released from the selectorCache object,
// there is no risk of memory leaks. Therefore, Map is used here instead of WeakMap.
var cachedAttrsIsStaticMap = new Map([[emptyAttrs, true]])
var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g
var selectorCache = Object.create(null)
function isEmpty(object) {
	for (var key in object) if (hasOwn.call(object, key)) return false
	return true
}
function isFormAttributeKey(key) {
	return key === "value" || key === "checked" || key === "selectedIndex" || key === "selected"
}
function compileSelector(selector) {
	var match, tag = "div", classes = [], attrs = {}, isStatic = true
	while (match = selectorParser.exec(selector)) {
		var type = match[1], value = match[2]
		if (type === "" && value !== "") tag = value
		else if (type === "#") attrs.id = value
		else if (type === ".") classes.push(value)
		else if (match[3][0] === "[") {
			var attrValue = match[6]
			if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\")
			if (match[4] === "class") classes.push(attrValue)
			else {
				attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true
				if (isFormAttributeKey(match[4])) isStatic = false
			}
		}
	}
	if (classes.length > 0) attrs.className = classes.join(" ")
	if (isEmpty(attrs)) attrs = emptyAttrs
	else cachedAttrsIsStaticMap.set(attrs, isStatic)
	return selectorCache[selector] = {tag: tag, attrs: attrs, is: attrs.is}
}
function execSelector(state, vnode) {
	vnode.tag = state.tag
	var attrs = vnode.attrs
	if (attrs == null) {
		vnode.attrs = state.attrs
		vnode.is = state.is
		return vnode
	}
	if (hasOwn.call(attrs, "class")) {
		if (attrs.class != null) attrs.className = attrs.class
		attrs.class = null
	}
	if (state.attrs !== emptyAttrs) {
		var className = attrs.className
		attrs = Object.assign({}, state.attrs, attrs)
		if (state.attrs.className != null) attrs.className =
			className != null
				? String(state.attrs.className) + " " + String(className)
				: state.attrs.className
	}
	// workaround for #2622 (reorder keys in attrs to set "type" first)
	// The DOM does things to inputs based on the "type", so it needs set first.
	// See: https://github.com/MithrilJS/mithril.js/issues/2622
	if (state.tag === "input" && hasOwn.call(attrs, "type")) {
		attrs = Object.assign({type: attrs.type}, attrs)
	}
	// This reduces the complexity of the evaluation of "is" within the render function.
	vnode.is = attrs.is
	vnode.attrs = attrs
	return vnode
}
function hyperscript(selector, attrs, ...children) {
	if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
		throw Error("The selector must be either a string or a component.");
	}
	var vnode = hyperscriptVnode(attrs, children)
	if (typeof selector === "string") {
		vnode.children = Vnode.normalizeChildren(vnode.children)
		if (selector !== "[") return execSelector(selectorCache[selector] || compileSelector(selector), vnode)
	}
	if (vnode.attrs == null) vnode.attrs = {}
	vnode.tag = selector
	return vnode
}
hyperscript.trust = function(html) {
	if (html == null) html = ""
	return Vnode("<", undefined, undefined, html, undefined, undefined)
}
hyperscript.fragment = function(attrs4, ...children1) {
	var vnode2 = hyperscriptVnode(attrs4, children1)
	if (vnode2.attrs == null) vnode2.attrs = {}
	vnode2.tag = "["
	vnode2.children = Vnode.normalizeChildren(vnode2.children)
	return vnode2
}
;
hyperscript.dom = function(els) {
	if (els == null)
		return Vnode("<", undefined, undefined, "", undefined, undefined)
	var children2 = []
	for (var i = 0; i < els.length; i++)
		children2.push(
			Vnode(els[i].tagName, i, undefined, undefined, undefined, undefined)
		)
	var vnode3 = Vnode("!", undefined, undefined, children2, undefined, undefined)
	vnode3.els = els
	return vnode3
}
;
var delayedRemoval = new WeakMap
function *domFor(vnode5) {
	// To avoid unintended mangling of the internal bundler,
	// parameter destructuring is not used here.
	var dom = vnode5.dom
	var domSize0 = vnode5.domSize
	var generation0 = delayedRemoval.get(dom)
	if (dom != null) do {
		var nextSibling = dom.nextSibling
		if (delayedRemoval.get(dom) === generation0) {
			yield dom
			domSize0--
		}
		dom = nextSibling
	}
	while (domSize0)
}
var _16 = function() {
	var nameSpace = {
		svg: "http://www.w3.org/2000/svg",
		math: "http://www.w3.org/1998/Math/MathML"
	}
	var currentRedraw
	var currentRender
	function getDocument(dom) {
		return dom.ownerDocument;
	}
	function getNameSpace(vnode4) {
		return vnode4.attrs && vnode4.attrs.xmlns || nameSpace[vnode4.tag]
	}
	//sanity check to discourage people from doing `vnode.state = ...`
	function checkState(vnode4, original) {
		if (vnode4.state !== original) throw new Error("'vnode.state' must not be modified.")
	}
	//Note: the hook is passed as the `this` argument to allow proxying the
	//arguments without requiring a full array allocation to do so. It also
	//takes advantage of the fact the current `vnode` is the first argument in
	//all lifecycle methods.
	function callHook(vnode4) {
		var original = vnode4.state
		try {
			return this.apply(original, arguments)
		} finally {
			checkState(vnode4, original)
		}
	}
	// IE11 (at least) throws an UnspecifiedError when accessing document.activeElement when
	// inside an iframe. Catch and swallow this error, and heavy-handidly return null.
	function activeElement(dom) {
		try {
			return getDocument(dom).activeElement
		} catch (e) {
			return null
		}
	}
	//create
	function createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {
		for (var i = start; i < end; i++) {
			var vnode4 = vnodes[i]
			if (vnode4 != null) {
				createNode(parent, vnode4, hooks, ns, nextSibling)
			}
		}
	}
	function createNode(parent, vnode4, hooks, ns, nextSibling) {
		var tag = vnode4.tag
		if (typeof tag === "string") {
			vnode4.state = {}
			if (vnode4.attrs != null) initLifecycle(vnode4.attrs, vnode4, hooks)
			switch (tag) {
				case "#": createText(parent, vnode4, nextSibling); break
				case "<": createHTML(parent, vnode4, ns, nextSibling); break
				case "[": createFragment(parent, vnode4, hooks, ns, nextSibling); break
				case "!": createDOM(parent, vnode4, ns, nextSibling); break
				default: createElement(parent, vnode4, hooks, ns, nextSibling)
			}
		}
		else createComponent(parent, vnode4, hooks, ns, nextSibling)
	}
	function createText(parent, vnode4, nextSibling) {
		vnode4.dom = getDocument(parent).createTextNode(vnode4.children)
		insertDOM(parent, vnode4.dom, nextSibling)
	}
	var possibleParents = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"}
	function createHTML(parent, vnode4, ns, nextSibling) {
		var match0 = vnode4.children.match(/^\s*?<(\w+)/im) || []
		// not using the proper parent makes the child element(s) vanish.
		//     var div = document.createElement("div")
		//     div.innerHTML = "<td>i</td><td>j</td>"
		//     console.log(div.innerHTML)
		// --> "ij", no <td> in sight.
		var temp = getDocument(parent).createElement(possibleParents[match0[1]] || "div")
		if (ns === "http://www.w3.org/2000/svg") {
			temp.innerHTML = "<svg xmlns=\"http://www.w3.org/2000/svg\">" + vnode4.children + "</svg>"
			temp = temp.firstChild
		} else {
			temp.innerHTML = vnode4.children
		}
		vnode4.dom = temp.firstChild
		vnode4.domSize = temp.childNodes.length
		var fragment = getDocument(parent).createDocumentFragment()
		var child
		while (child = temp.firstChild) {
			fragment.appendChild(child)
		}
		insertDOM(parent, fragment, nextSibling)
	}
	function createFragment(parent, vnode4, hooks, ns, nextSibling) {
		var fragment = getDocument(parent).createDocumentFragment()
		if (vnode4.children != null) {
			var children3 = vnode4.children
			createNodes(fragment, children3, 0, children3.length, hooks, null, ns)
		}
		vnode4.dom = fragment.firstChild
		vnode4.domSize = fragment.childNodes.length
		insertDOM(parent, fragment, nextSibling)
	}
	function createDOM(parent, vnode4, ns, nextSibling) {
		var fragment = getDocument(parent).createDocumentFragment()
		if (vnode4.els != null) {
			for (var i = 0; i < vnode4.els.length; i++) {
				fragment.appendChild(vnode4.els[i].cloneNode(true))
			}
		}
		vnode4.dom = fragment.firstChild
		vnode4.domSize = vnode4.els.length
		insertDOM(parent, fragment, nextSibling)
	}
	function createElement(parent, vnode4, hooks, ns, nextSibling) {
		var tag = vnode4.tag
		var attrs5 = vnode4.attrs
		var is = vnode4.is
		ns = getNameSpace(vnode4) || ns
		var element = ns ?
			is ? getDocument(parent).createElementNS(ns, tag, {is: is}) : getDocument(parent).createElementNS(ns, tag) :
			is ? getDocument(parent).createElement(tag, {is: is}) : getDocument(parent).createElement(tag)
		vnode4.dom = element
		if (attrs5 != null) {
			setAttrs(vnode4, attrs5, ns)
		}
		insertDOM(parent, element, nextSibling)
		if (!maybeSetContentEditable(vnode4)) {
			if (vnode4.children != null) {
				var children3 = vnode4.children
				createNodes(element, children3, 0, children3.length, hooks, null, ns)
				if (vnode4.tag === "select" && attrs5 != null) setLateSelectAttrs(vnode4, attrs5)
			}
		}
	}
	function initComponent(vnode4, hooks) {
		var sentinel
		if (typeof vnode4.tag.view === "function") {
			vnode4.state = Object.create(vnode4.tag)
			sentinel = vnode4.state.view
			if (sentinel.$$reentrantLock$$ != null) return
			sentinel.$$reentrantLock$$ = true
		} else {
			vnode4.state = void 0
			sentinel = vnode4.tag
			if (sentinel.$$reentrantLock$$ != null) return
			sentinel.$$reentrantLock$$ = true
			vnode4.state = (vnode4.tag.prototype != null && typeof vnode4.tag.prototype.view === "function") ? new vnode4.tag(vnode4) : vnode4.tag(vnode4)
		}
		initLifecycle(vnode4.state, vnode4, hooks)
		if (vnode4.attrs != null) initLifecycle(vnode4.attrs, vnode4, hooks)
		vnode4.instance = Vnode.normalize(callHook.call(vnode4.state.view, vnode4))
		if (vnode4.instance === vnode4) throw Error("A view cannot return the vnode it received as argument")
		sentinel.$$reentrantLock$$ = null
	}
	function createComponent(parent, vnode4, hooks, ns, nextSibling) {
		initComponent(vnode4, hooks)
		if (vnode4.instance != null) {
			createNode(parent, vnode4.instance, hooks, ns, nextSibling)
			vnode4.dom = vnode4.instance.dom
			vnode4.domSize = vnode4.instance.domSize
		}
		else {
			vnode4.domSize = 0
		}
	}
	//update
	/**
	 * @param {Element|Fragment} parent - the parent element
	 * @param {Vnode[] | null} old - the list of vnodes of the last `render()` call for
	 *                               this part of the tree
	 * @param {Vnode[] | null} vnodes - as above, but for the current `render()` call.
	 * @param {Function[]} hooks - an accumulator of post-render hooks (oncreate/onupdate)
	 * @param {Element | null} nextSibling - the next DOM node if we're dealing with a
	 *                                       fragment that is not the last item in its
	 *                                       parent
	 * @param {'svg' | 'math' | String | null} ns) - the current XML namespace, if any
	 * @returns void
	 */
	// This function diffs and patches lists of vnodes, both keyed and unkeyed.
	//
	//
	// 1. describe its general structure
	// 2. focus on the diff algorithm optimizations
	// 3. discuss DOM node operations.
	// ## Overview:
	//
	// The updateNodes() function:
	// - deals with trivial cases
	// - determines whether the lists are keyed or unkeyed based on the first non-null node
	//   of each list.
	// - diffs them and patches the DOM if needed (that's the brunt of the code)
	// - manages the leftovers: after diffing, are there:
	//   - old nodes left to remove?
	// 	 - new nodes to insert?
	// 	 deal with them!
	//
	// The lists are only iterated over once, with an exception for the nodes in `old` that
	// are visited in the fourth part of the diff and in the `removeNodes` loop.
	// ## Diffing
	//
	// Reading https://github.com/localvoid/ivi/blob/ddc09d06abaef45248e6133f7040d00d3c6be853/packages/ivi/src/vdom/implementation.ts#L617-L837
	// may be good for context on longest increasing subsequence-based logic for moving nodes.
	//
	// In order to diff keyed lists, one has to
	//
	// 1) match nodes in both lists, per key, and update them accordingly
	// 2) create the nodes present in the new list, but absent in the old one
	// 3) remove the nodes present in the old list, but absent in the new one
	// 4) figure out what nodes in 1) to move in order to minimize the DOM operations.
	//
	// To achieve 1) one can create a dictionary of keys => index (for the old list), then iterate
	// over the new list and for each new vnode, find the corresponding vnode in the old list using
	// the map.
	// 2) is achieved in the same step: if a new node has no corresponding entry in the map, it is new
	// and must be created.
	// For the removals, we actually remove the nodes that have been updated from the old list.
	// The nodes that remain in that list after 1) and 2) have been performed can be safely removed.
	// The fourth step is a bit more complex and relies on the longest increasing subsequence (LIS)
	// algorithm.
	//
	// the longest increasing subsequence is the list of nodes that can remain in place. Imagine going
	// from `1,2,3,4,5` to `4,5,1,2,3` where the numbers are not necessarily the keys, but the indices
	// corresponding to the keyed nodes in the old list (keyed nodes `e,d,c,b,a` => `b,a,e,d,c` would
	//  match the above lists, for example).
	//
	// In there are two increasing subsequences: `4,5` and `1,2,3`, the latter being the longest. We
	// can update those nodes without moving them, and only call `insertNode` on `4` and `5`.
	//
	// @localvoid adapted the algo to also support node deletions and insertions (the `lis` is actually
	// the longest increasing subsequence *of old nodes still present in the new list*).
	//
	// It is a general algorithm that is fireproof in all circumstances, but it requires the allocation
	// and the construction of a `key => oldIndex` map, and three arrays (one with `newIndex => oldIndex`,
	// the `LIS` and a temporary one to create the LIS).
	//
	// So we cheat where we can: if the tails of the lists are identical, they are guaranteed to be part of
	// the LIS and can be updated without moving them.
	//
	// If two nodes are swapped, they are guaranteed not to be part of the LIS, and must be moved (with
	// the exception of the last node if the list is fully reversed).
	//
	// ## Finding the next sibling.
	//
	// `updateNode()` and `createNode()` expect a nextSibling parameter to perform DOM operations.
	// When the list is being traversed top-down, at any index, the DOM nodes up to the previous
	// vnode reflect the content of the new list, whereas the rest of the DOM nodes reflect the old
	// list. The next sibling must be looked for in the old list using `getNextSibling(... oldStart + 1 ...)`.
	//
	// In the other scenarios (swaps, upwards traversal, map-based diff),
	// the new vnodes list is traversed upwards. The DOM nodes at the bottom of the list reflect the
	// bottom part of the new vnodes list, and we can use the `v.dom`  value of the previous node
	// as the next sibling (cached in the `nextSibling` variable).
	// ## DOM node moves
	//
	// In most scenarios `updateNode()` and `createNode()` perform the DOM operations. However,
	// this is not the case if the node moved (second and fourth part of the diff algo). We move
	// the old DOM nodes before updateNode runs because it enables us to use the cached `nextSibling`
	// variable rather than fetching it using `getNextSibling()`.
	function updateNodes(parent, old, vnodes, hooks, nextSibling, ns) {
		if (old === vnodes || old == null && vnodes == null) return
		else if (old == null || old.length === 0) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)
		else if (vnodes == null || vnodes.length === 0) removeNodes(parent, old, 0, old.length)
		else {
			var isOldKeyed = old[0] != null && old[0].key != null
			var isKeyed = vnodes[0] != null && vnodes[0].key != null
			var start = 0, oldStart = 0
			if (!isOldKeyed) while (oldStart < old.length && old[oldStart] == null) oldStart++
			if (!isKeyed) while (start < vnodes.length && vnodes[start] == null) start++
			if (isOldKeyed !== isKeyed) {
				removeNodes(parent, old, oldStart, old.length)
				createNodes(parent, vnodes, start, vnodes.length, hooks, nextSibling, ns)
			} else if (!isKeyed) {
				// Don't index past the end of either list (causes deopts).
				var commonLength = old.length < vnodes.length ? old.length : vnodes.length
				// Rewind if necessary to the first non-null index on either side.
				// We could alternatively either explicitly create or remove nodes when `start !== oldStart`
				// but that would be optimizing for sparse lists which are more rare than dense ones.
				start = start < oldStart ? start : oldStart
				for (; start < commonLength; start++) {
					o = old[start]
					v = vnodes[start]
					if (o === v || o == null && v == null) continue
					else if (o == null) createNode(parent, v, hooks, ns, getNextSibling(old, start + 1, nextSibling))
					else if (v == null) removeNode(parent, o)
					else updateNode(parent, o, v, hooks, getNextSibling(old, start + 1, nextSibling), ns)
				}
				if (old.length > commonLength) removeNodes(parent, old, start, old.length)
				if (vnodes.length > commonLength) createNodes(parent, vnodes, start, vnodes.length, hooks, nextSibling, ns)
			} else {
				// keyed diff
				var oldEnd = old.length - 1, end = vnodes.length - 1, map, o, v, oe, ve, topSibling
				// bottom-up
				while (oldEnd >= oldStart && end >= start) {
					oe = old[oldEnd]
					ve = vnodes[end]
					if (oe.key !== ve.key) break
					if (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns)
					if (ve.dom != null) nextSibling = ve.dom
					oldEnd--, end--
				}
				// top-down
				while (oldEnd >= oldStart && end >= start) {
					o = old[oldStart]
					v = vnodes[start]
					if (o.key !== v.key) break
					oldStart++, start++
					if (o !== v) updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), ns)
				}
				// swaps and list reversals
				while (oldEnd >= oldStart && end >= start) {
					if (start === end) break
					if (o.key !== ve.key || oe.key !== v.key) break
					topSibling = getNextSibling(old, oldStart, nextSibling)
					moveDOM(parent, oe, topSibling)
					if (oe !== v) updateNode(parent, oe, v, hooks, topSibling, ns)
					if (++start <= --end) moveDOM(parent, o, nextSibling)
					if (o !== ve) updateNode(parent, o, ve, hooks, nextSibling, ns)
					if (ve.dom != null) nextSibling = ve.dom
					oldStart++; oldEnd--
					oe = old[oldEnd]
					ve = vnodes[end]
					o = old[oldStart]
					v = vnodes[start]
				}
				// bottom up once again
				while (oldEnd >= oldStart && end >= start) {
					if (oe.key !== ve.key) break
					if (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns)
					if (ve.dom != null) nextSibling = ve.dom
					oldEnd--, end--
					oe = old[oldEnd]
					ve = vnodes[end]
				}
				if (start > end) removeNodes(parent, old, oldStart, oldEnd + 1)
				else if (oldStart > oldEnd) createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)
				else {
					// inspired by ivi https://github.com/ivijs/ivi/ by Boris Kaul
					var originalNextSibling = nextSibling, vnodesLength = end - start + 1, oldIndices = new Array(vnodesLength), li=0, i=0, pos = 2147483647, matched = 0, map, lisIndices
					for (i = 0; i < vnodesLength; i++) oldIndices[i] = -1
					for (i = end; i >= start; i--) {
						if (map == null) map = getKeyMap(old, oldStart, oldEnd + 1)
						ve = vnodes[i]
						var oldIndex = map[ve.key]
						if (oldIndex != null) {
							pos = (oldIndex < pos) ? oldIndex : -1 // becomes -1 if nodes were re-ordered
							oldIndices[i-start] = oldIndex
							oe = old[oldIndex]
							old[oldIndex] = null
							if (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns)
							if (ve.dom != null) nextSibling = ve.dom
							matched++
						}
					}
					nextSibling = originalNextSibling
					if (matched !== oldEnd - oldStart + 1) removeNodes(parent, old, oldStart, oldEnd + 1)
					if (matched === 0) createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)
					else {
						if (pos === -1) {
							// the indices of the indices of the items that are part of the
							// longest increasing subsequence in the oldIndices list
							lisIndices = makeLisIndices(oldIndices)
							li = lisIndices.length - 1
							for (i = end; i >= start; i--) {
								v = vnodes[i]
								if (oldIndices[i-start] === -1) createNode(parent, v, hooks, ns, nextSibling)
								else {
									if (lisIndices[li] === i - start) li--
									else moveDOM(parent, v, nextSibling)
								}
								if (v.dom != null) nextSibling = vnodes[i].dom
							}
						} else {
							for (i = end; i >= start; i--) {
								v = vnodes[i]
								if (oldIndices[i-start] === -1) createNode(parent, v, hooks, ns, nextSibling)
								if (v.dom != null) nextSibling = vnodes[i].dom
							}
						}
					}
				}
			}
		}
	}
	function updateNode(parent, old, vnode4, hooks, nextSibling, ns) {
		var oldTag = old.tag, tag = vnode4.tag
		if (oldTag === tag && old.is === vnode4.is) {
			vnode4.state = old.state
			vnode4.events = old.events
			if (shouldNotUpdate(vnode4, old)) return
			if (typeof oldTag === "string") {
				if (vnode4.attrs != null) {
					updateLifecycle(vnode4.attrs, vnode4, hooks)
				}
				switch (oldTag) {
					case "#": updateText(old, vnode4); break
					case "<": updateHTML(parent, old, vnode4, ns, nextSibling); break
					case "[": updateFragment(parent, old, vnode4, hooks, nextSibling, ns); break
					case "!": updateDOM(parent, old, vnode4, nextSibling); break
					default: updateElement(old, vnode4, hooks, ns)
				}
			}
			else updateComponent(parent, old, vnode4, hooks, nextSibling, ns)
		}
		else {
			removeNode(parent, old)
			createNode(parent, vnode4, hooks, ns, nextSibling)
		}
	}
	function updateText(old, vnode4) {
		if (old.children.toString() !== vnode4.children.toString()) {
			old.dom.nodeValue = vnode4.children
		}
		vnode4.dom = old.dom
	}
	function updateHTML(parent, old, vnode4, ns, nextSibling) {
		if (old.children !== vnode4.children) {
			removeDOM(parent, old)
			createHTML(parent, vnode4, ns, nextSibling)
		}
		else {
			vnode4.dom = old.dom
			vnode4.domSize = old.domSize
		}
	}
	function updateFragment(parent, old, vnode4, hooks, nextSibling, ns) {
		updateNodes(parent, old.children, vnode4.children, hooks, nextSibling, ns)
		var domSize = 0, children3 = vnode4.children
		vnode4.dom = null
		if (children3 != null) {
			for (var i = 0; i < children3.length; i++) {
				var child = children3[i]
				if (child != null && child.dom != null) {
					if (vnode4.dom == null) vnode4.dom = child.dom
					domSize += child.domSize || 1
				}
			}
		}
		vnode4.domSize = domSize
	}
	function updateDOM(parent, old, vnode4, nextSibling, ns) {
		if (old.els !== vnode4.els) {
			removeDOM(parent, old)
			createDOM(parent, vnode4, ns, nextSibling)
		}
		else {
			vnode4.dom = old.dom
			vnode4.domSize = old.domSize
		}
	}
	function updateElement(old, vnode4, hooks, ns) {
		var element = vnode4.dom = old.dom
		ns = getNameSpace(vnode4) || ns
		if (old.attrs != vnode4.attrs || (vnode4.attrs != null && !cachedAttrsIsStaticMap.get(vnode4.attrs))) {
			updateAttrs(vnode4, old.attrs, vnode4.attrs, ns)
		}
		if (!maybeSetContentEditable(vnode4)) {
			updateNodes(element, old.children, vnode4.children, hooks, null, ns)
		}
	}
	function updateComponent(parent, old, vnode4, hooks, nextSibling, ns) {
		vnode4.instance = Vnode.normalize(callHook.call(vnode4.state.view, vnode4))
		if (vnode4.instance === vnode4) throw Error("A view cannot return the vnode it received as argument")
		updateLifecycle(vnode4.state, vnode4, hooks)
		if (vnode4.attrs != null) updateLifecycle(vnode4.attrs, vnode4, hooks)
		if (vnode4.instance != null) {
			if (old.instance == null) createNode(parent, vnode4.instance, hooks, ns, nextSibling)
			else updateNode(parent, old.instance, vnode4.instance, hooks, nextSibling, ns)
			vnode4.dom = vnode4.instance.dom
			vnode4.domSize = vnode4.instance.domSize
		}
		else {
			if (old.instance != null) removeNode(parent, old.instance)
			vnode4.domSize = 0
		}
	}
	function getKeyMap(vnodes, start, end) {
		var map = Object.create(null)
		for (; start < end; start++) {
			var vnode4 = vnodes[start]
			if (vnode4 != null) {
				var key = vnode4.key
				if (key != null) map[key] = start
			}
		}
		return map
	}
	// Lifted from ivi https://github.com/ivijs/ivi/
	// takes a list of unique numbers (-1 is special and can
	// occur multiple times) and returns an array with the indices
	// of the items that are part of the longest increasing
	// subsequence
	var lisTemp = []
	function makeLisIndices(a) {
		var result = [0]
		var u = 0, v = 0, i = 0
		var il = lisTemp.length = a.length
		for (var i = 0; i < il; i++) lisTemp[i] = a[i]
		for (var i = 0; i < il; ++i) {
			if (a[i] === -1) continue
			var j = result[result.length - 1]
			if (a[j] < a[i]) {
				lisTemp[i] = j
				result.push(i)
				continue
			}
			u = 0
			v = result.length - 1
			while (u < v) {
				// Fast integer average without overflow.
				// eslint-disable-next-line no-bitwise
				var c = (u >>> 1) + (v >>> 1) + (u & v & 1)
				if (a[result[c]] < a[i]) {
					u = c + 1
				}
				else {
					v = c
				}
			}
			if (a[i] < a[result[u]]) {
				if (u > 0) lisTemp[i] = result[u - 1]
				result[u] = i
			}
		}
		u = result.length
		v = result[u - 1]
		while (u-- > 0) {
			result[u] = v
			v = lisTemp[v]
		}
		lisTemp.length = 0
		return result
	}
	function getNextSibling(vnodes, i, nextSibling) {
		for (; i < vnodes.length; i++) {
			if (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom
		}
		return nextSibling
	}
	// This handles fragments with zombie children (removed from vdom, but persisted in DOM through onbeforeremove)
	function moveDOM(parent, vnode4, nextSibling) {
		if (vnode4.dom != null) {
			var target
			if (vnode4.domSize == null || vnode4.domSize === 1) {
				// don't allocate for the common case
				target = vnode4.dom
			} else {
				target = getDocument(parent).createDocumentFragment()
				for (var dom of domFor(vnode4)) target.appendChild(dom)
			}
			insertDOM(parent, target, nextSibling)
		}
	}
	function insertDOM(parent, dom, nextSibling) {
		if (nextSibling != null) parent.insertBefore(dom, nextSibling)
		else parent.appendChild(dom)
	}
	function maybeSetContentEditable(vnode4) {
		if (vnode4.attrs == null || (
			vnode4.attrs.contenteditable == null && // attribute
			vnode4.attrs.contentEditable == null // property
		)) return false
		var children3 = vnode4.children
		if (children3 != null && children3.length === 1 && children3[0].tag === "<") {
			var content = children3[0].children
			if (vnode4.dom.innerHTML !== content) vnode4.dom.innerHTML = content
		}
		else if (children3 != null && children3.length !== 0) throw new Error("Child node of a contenteditable must be trusted.")
		return true
	}
	//remove
	function removeNodes(parent, vnodes, start, end) {
		for (var i = start; i < end; i++) {
			var vnode4 = vnodes[i]
			if (vnode4 != null) removeNode(parent, vnode4)
		}
	}
	function tryBlockRemove(parent, vnode4, source, counter) {
		var original = vnode4.state
		var result = callHook.call(source.onbeforeremove, vnode4)
		if (result == null) return
		var generation = currentRender
		for (var dom of domFor(vnode4)) delayedRemoval.set(dom, generation)
		counter.v++
		Promise.resolve(result).finally(function () {
			checkState(vnode4, original)
			tryResumeRemove(parent, vnode4, counter)
		})
	}
	function tryResumeRemove(parent, vnode4, counter) {
		if (--counter.v === 0) {
			onremove(vnode4)
			removeDOM(parent, vnode4)
		}
	}
	function removeNode(parent, vnode4) {
		var counter = {v: 1}
		if (typeof vnode4.tag !== "string" && typeof vnode4.state.onbeforeremove === "function") tryBlockRemove(parent, vnode4, vnode4.state, counter)
		if (vnode4.attrs && typeof vnode4.attrs.onbeforeremove === "function") tryBlockRemove(parent, vnode4, vnode4.attrs, counter)
		tryResumeRemove(parent, vnode4, counter)
	}
	function removeDOM(parent, vnode4) {
		if (vnode4.dom == null) return
		if (vnode4.domSize == null || vnode4.domSize === 1) {
			parent.removeChild(vnode4.dom)
		} else {
			for (var dom of domFor(vnode4)) parent.removeChild(dom)
		}
	}
	function onremove(vnode4) {
		if (typeof vnode4.tag !== "string" && typeof vnode4.state.onremove === "function") callHook.call(vnode4.state.onremove, vnode4)
		if (vnode4.attrs && typeof vnode4.attrs.onremove === "function") callHook.call(vnode4.attrs.onremove, vnode4)
		if (typeof vnode4.tag !== "string") {
			if (vnode4.instance != null) onremove(vnode4.instance)
		} else {
			if (vnode4.events != null) vnode4.events._ = null
			var children3 = vnode4.children
			if (Array.isArray(children3)) {
				for (var i = 0; i < children3.length; i++) {
					var child = children3[i]
					if (child != null) onremove(child)
				}
			}
		}
	}
	//attrs
	function setAttrs(vnode4, attrs5, ns) {
		for (var key in attrs5) {
			setAttr(vnode4, key, null, attrs5[key], ns)
		}
	}
	function setAttr(vnode4, key, old, value, ns) {
		if (key === "key" || value == null || isLifecycleMethod(key) || (old === value && !isFormAttribute(vnode4, key)) && typeof value !== "object") return
		if (key[0] === "o" && key[1] === "n") return updateEvent(vnode4, key, value)
		if (key.slice(0, 6) === "xlink:") vnode4.dom.setAttributeNS("http://www.w3.org/1999/xlink", key.slice(6), value)
		else if (key === "style") updateStyle(vnode4.dom, old, value)
		else if (hasPropertyKey(vnode4, key, ns)) {
			if (key === "value") {
				// Only do the coercion if we're actually going to check the value.
				/* eslint-disable no-implicit-coercion */
				//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
				//setting input[type=file][value] to same value causes an error to be generated if it's non-empty
				//minlength/maxlength validation isn't performed on script-set values(#2256)
				if ((vnode4.tag === "input" || vnode4.tag === "textarea") && vnode4.dom.value === "" + value) return
				//setting select[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode4.tag === "select" && old !== null && vnode4.dom.value === "" + value) return
				//setting option[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode4.tag === "option" && old !== null && vnode4.dom.value === "" + value) return
				//setting input[type=file][value] to different value is an error if it's non-empty
				// Not ideal, but it at least works around the most common source of uncaught exceptions for now.
				if (vnode4.tag === "input" && vnode4.attrs.type === "file" && "" + value !== "") { console.error("`value` is read-only on file inputs!"); return }
				/* eslint-enable no-implicit-coercion */
			}
			// If you assign an input type that is not supported by IE 11 with an assignment expression, an error will occur.
			if (vnode4.tag === "input" && key === "type") vnode4.dom.setAttribute(key, value)
			else vnode4.dom[key] = value
		} else {
			if (typeof value === "boolean") {
				if (value) vnode4.dom.setAttribute(key, "")
				else vnode4.dom.removeAttribute(key)
			}
			else vnode4.dom.setAttribute(key === "className" ? "class" : key, value)
		}
	}
	function removeAttr(vnode4, key, old, ns) {
		if (key === "key" || old == null || isLifecycleMethod(key)) return
		if (key[0] === "o" && key[1] === "n") updateEvent(vnode4, key, undefined)
		else if (key === "style") updateStyle(vnode4.dom, old, null)
		else if (
			hasPropertyKey(vnode4, key, ns)
			&& key !== "className"
			&& key !== "title" // creates "null" as title
			&& !(key === "value" && (
				vnode4.tag === "option"
				|| vnode4.tag === "select" && vnode4.dom.selectedIndex === -1 && vnode4.dom === activeElement(vnode4.dom)
			))
			&& !(vnode4.tag === "input" && key === "type")
		) {
			vnode4.dom[key] = null
		} else {
			var nsLastIndex = key.indexOf(":")
			if (nsLastIndex !== -1) key = key.slice(nsLastIndex + 1)
			if (old !== false) vnode4.dom.removeAttribute(key === "className" ? "class" : key)
		}
	}
	function setLateSelectAttrs(vnode4, attrs5) {
		if ("value" in attrs5) {
			if(attrs5.value === null) {
				if (vnode4.dom.selectedIndex !== -1) vnode4.dom.value = null
			} else {
				var normalized = "" + attrs5.value // eslint-disable-line no-implicit-coercion
				if (vnode4.dom.value !== normalized || vnode4.dom.selectedIndex === -1) {
					vnode4.dom.value = normalized
				}
			}
		}
		if ("selectedIndex" in attrs5) setAttr(vnode4, "selectedIndex", null, attrs5.selectedIndex, undefined)
	}
	function updateAttrs(vnode4, old, attrs5, ns) {
		// Some attributes may NOT be case-sensitive (e.g. data-***),
		// so removal should be done first to prevent accidental removal for newly setting values.
		var val
		if (old != null) {
			if (old === attrs5 && !cachedAttrsIsStaticMap.has(attrs5)) {
				console.warn("Don't reuse attrs object, use new object for every redraw, this will throw in next major")
			}
			for (var key in old) {
				if (((val = old[key]) != null) && (attrs5 == null || attrs5[key] == null)) {
					removeAttr(vnode4, key, val, ns)
				}
			}
		}
		if (attrs5 != null) {
			for (var key in attrs5) {
				setAttr(vnode4, key, old && old[key], attrs5[key], ns)
			}
		}
	}
	function isFormAttribute(vnode4, attr) {
		return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && (vnode4.dom === activeElement(vnode4.dom) || vnode4.tag === "option" && vnode4.dom.parentNode === activeElement(vnode4.dom))
	}
	function isLifecycleMethod(attr) {
		return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"
	}
	function hasPropertyKey(vnode4, key, ns) {
		// Filter out namespaced keys
		return ns === undefined && (
			// If it's a custom element, just keep it.
			vnode4.tag.indexOf("-") > -1 || vnode4.is ||
			// If it's a normal element, let's try to avoid a few browser bugs.
			key !== "href" && key !== "list" && key !== "form" && key !== "width" && key !== "height"// && key !== "type"
			// Defer the property check until *after* we check everything.
		) && key in vnode4.dom
	}
	//style
	function updateStyle(element, old, style) {
		if (old === style) {
			// Styles are equivalent, do nothing.
		} else if (style == null) {
			// New style is missing, just clear it.
			element.style = ""
		} else if (typeof style !== "object") {
			// New style is a string, let engine deal with patching.
			element.style = style
		} else if (old == null || typeof old !== "object") {
			// `old` is missing or a string, `style` is an object.
			element.style = ""
			// Add new style properties
			for (var key in style) {
				var value = style[key]
				if (value != null) {
					if (key.includes("-")) element.style.setProperty(key, String(value))
					else element.style[key] = String(value)
				}
			}
		} else {
			// Both old & new are (different) objects.
			// Remove style properties that no longer exist
			// Style properties may have two cases(dash-case and camelCase),
			// so removal should be done first to prevent accidental removal for newly setting values.
			for (var key in old) {
				if (old[key] != null && style[key] == null) {
					if (key.includes("-")) element.style.removeProperty(key)
					else element.style[key] = ""
				}
			}
			// Update style properties that have changed
			for (var key in style) {
				var value = style[key]
				if (value != null && (value = String(value)) !== String(old[key])) {
					if (key.includes("-")) element.style.setProperty(key, value)
					else element.style[key] = value
				}
			}
		}
	}
	// Here's an explanation of how this works:
	// 1. The event names are always (by design) prefixed by `on`.
	// 2. The EventListener interface accepts either a function or an object
	//    with a `handleEvent` method.
	// 3. The object does not inherit from `Object.prototype`, to avoid
	//    any potential interference with that (e.g. setters).
	// 4. The event name is remapped to the handler before calling it.
	// 5. In function-based event handlers, `ev.target === this`. We replicate
	//    that below.
	// 6. In function-based event handlers, `return false` prevents the default
	//    action and stops event propagation. We replicate that below.
	function EventDict() {
		// Save this, so the current redraw is correctly tracked.
		this._ = currentRedraw
	}
	EventDict.prototype = Object.create(null)
	EventDict.prototype.handleEvent = function (ev) {
		var handler = this["on" + ev.type]
		var result
		if (typeof handler === "function") result = handler.call(ev.currentTarget, ev)
		else if (typeof handler.handleEvent === "function") handler.handleEvent(ev)
		var self = this
		if (self._ != null) {
			if (ev.redraw !== false) (0, self._)()
			if (result != null && typeof result.then === "function") {
				Promise.resolve(result).then(function () {
					if (self._ != null && ev.redraw !== false) (0, self._)()
				})
			}
		}
		if (result === false) {
			ev.preventDefault()
			ev.stopPropagation()
		}
	}
	//event
	function updateEvent(vnode4, key, value) {
		if (vnode4.events != null) {
			vnode4.events._ = currentRedraw
			if (vnode4.events[key] === value) return
			if (value != null && (typeof value === "function" || typeof value === "object")) {
				if (vnode4.events[key] == null) vnode4.dom.addEventListener(key.slice(2), vnode4.events, false)
				vnode4.events[key] = value
			} else {
				if (vnode4.events[key] != null) vnode4.dom.removeEventListener(key.slice(2), vnode4.events, false)
				vnode4.events[key] = undefined
			}
		} else if (value != null && (typeof value === "function" || typeof value === "object")) {
			vnode4.events = new EventDict()
			vnode4.dom.addEventListener(key.slice(2), vnode4.events, false)
			vnode4.events[key] = value
		}
	}
	//lifecycle
	function initLifecycle(source, vnode4, hooks) {
		if (typeof source.oninit === "function") callHook.call(source.oninit, vnode4)
		if (typeof source.oncreate === "function") hooks.push(callHook.bind(source.oncreate, vnode4))
	}
	function updateLifecycle(source, vnode4, hooks) {
		if (typeof source.onupdate === "function") hooks.push(callHook.bind(source.onupdate, vnode4))
	}
	function shouldNotUpdate(vnode4, old) {
		do {
			if (vnode4.attrs != null && typeof vnode4.attrs.onbeforeupdate === "function") {
				var force = callHook.call(vnode4.attrs.onbeforeupdate, vnode4, old)
				if (force !== undefined && !force) break
			}
			if (typeof vnode4.tag !== "string" && typeof vnode4.state.onbeforeupdate === "function") {
				var force = callHook.call(vnode4.state.onbeforeupdate, vnode4, old)
				if (force !== undefined && !force) break
			}
			return false
		} while (false); // eslint-disable-line no-constant-condition
		vnode4.dom = old.dom
		vnode4.domSize = old.domSize
		vnode4.instance = old.instance
		// One would think having the actual latest attributes would be ideal,
		// but it doesn't let us properly diff based on our current internal
		// representation. We have to save not only the old DOM info, but also
		// the attributes used to create it, as we diff *that*, not against the
		// DOM directly (with a few exceptions in `setAttr`). And, of course, we
		// need to save the children and text as they are conceptually not
		// unlike special "attributes" internally.
		vnode4.attrs = old.attrs
		vnode4.children = old.children
		vnode4.text = old.text
		return true
	}
	var currentDOM
	return function(dom, vnodes, redraw) {
		if (!dom) throw new TypeError("DOM element being rendered to does not exist.")
		if (currentDOM != null && dom.contains(currentDOM)) {
			throw new TypeError("Node is currently being rendered to and thus is locked.")
		}
		var prevRedraw = currentRedraw
		var prevDOM = currentDOM
		var hooks = []
		var active = activeElement(dom)
		var namespace = dom.namespaceURI
		currentDOM = dom
		currentRedraw = typeof redraw === "function" ? redraw : undefined
		currentRender = {}
		try {
			// First time rendering into a node clears it out
			if (dom.vnodes == null) dom.textContent = ""
			vnodes = Vnode.normalizeChildren(Array.isArray(vnodes) ? vnodes : [vnodes])
			updateNodes(dom, dom.vnodes, vnodes, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace)
			dom.vnodes = vnodes
			// `document.activeElement` can return null: https://html.spec.whatwg.org/multipage/interaction.html#dom-document-activeelement
			if (active != null && activeElement(dom) !== active && typeof active.focus === "function") active.focus()
			for (var i = 0; i < hooks.length; i++) hooks[i]()
		} finally {
			currentRedraw = prevRedraw
			currentDOM = prevDOM
		}
	}
}
var render = _16()
var _23 = function(render2, schedule, console) {
	var subscriptions = []
	var pending = false
	var offset = -1
	function sync() {
		for (offset = 0; offset < subscriptions.length; offset += 2) {
			try { render2(subscriptions[offset], Vnode(subscriptions[offset + 1]), redraw) }
			catch (e) { console.error(e) }
		}
		offset = -1
	}
	function redraw() {
		if (!pending) {
			pending = true
			schedule(function() {
				pending = false
				sync()
			})
		}
	}
	redraw.sync = sync
	function mount(root, component) {
		if (component != null && component.view == null && typeof component !== "function") {
			throw new TypeError("m.mount expects a component, not a vnode.")
		}
		var index = subscriptions.indexOf(root)
		if (index >= 0) {
			subscriptions.splice(index, 2)
			if (index <= offset) offset -= 2
			render2(root, [])
		}
		if (component != null) {
			subscriptions.push(root, component)
			render2(root, Vnode(component), redraw)
		}
	}
	return {mount: mount, redraw: redraw}
}
var mountRedraw = _23(render, typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : null, typeof console !== "undefined" ? console : null)
//

// Note: this is mildly perf-sensitive.
//
// It does *not* use `delete` - dynamic `delete`s usually cause objects to bail
// out into dictionary mode and just generally cause a bunch of optimization
// issues within engines.
//
// Ideally, I would've preferred to do this, if it weren't for the optimization
// issues:
//
// ```js
// const hasOwn = hasOwn
// const magic = [
//     "key", "oninit", "oncreate", "onbeforeupdate", "onupdate",
//     "onbeforeremove", "onremove",
// ]
// var censor = (attrs, extras) => {
//     const result = Object.assign(Object.create(null), attrs)
//     for (const key of magic) delete result[key]
//     if (extras != null) for (const key of extras) delete result[key]
//     return result
// }
// ```
var magic = /^(?:key|oninit|oncreate|onbeforeupdate|onupdate|onbeforeremove|onremove)$/
var censor = function(attrs7, extras) {
	var result2 = {}
	if (extras != null) {
		for (var key6 in attrs7) {
			if (hasOwn.call(attrs7, key6) && !magic.test(key6) && extras.indexOf(key6) < 0) {
				result2[key6] = attrs7[key6]
			}
		}
	} else {
		for (var key6 in attrs7) {
			if (hasOwn.call(attrs7, key6) && !magic.test(key6)) {
				result2[key6] = attrs7[key6]
			}
		}
	}
	return result2
}

var m = function m() { return hyperscript.apply(this, arguments) }
m.m = hyperscript
m.trust = hyperscript.trust
m.fragment = hyperscript.fragment
m.dom = hyperscript.dom
m.Fragment = "["
m.mount = mountRedraw.mount
m.render = render
m.redraw = mountRedraw.redraw
m.vnode = Vnode
m.censor = censor
m.domFor = domFor

export default m

